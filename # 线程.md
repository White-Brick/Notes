# 线程
引入：  
在传统Unix模型中，当一个进程需要由另一个实体执行某件事时，该进程派生（fork）一个子进程，让子进程去进行处理。  
Unix下的大多数网络服务器程序都是这么编写的，即父进程接受连接，派生子进程，子进程处理与客户的交互。  

但是fork时有一些问题：
- fork昂贵。内存映射要从父进程拷贝到子进程，所有描述字要在子进程中复制等等。
- fork子进程后，需要用进程间通信（IPC）在父子进程之间传递信息。在fork之前的信息容易传递，因为子进程从一开始就有父进程数据空间及所有描述字的拷贝。但是从子进程返回信息给父进程需要做更多的工作。

线程有助于解决这两个问题。  
**一个进程中的所有子线程共享相同的全局内存**，这使得线程很容易共享信息，但是这种简易性也带来了同步问题。  
一个进程中的所有线程不仅共享全局变量，而且共享进程指令、大多数数据、打开的文件（如描述字）、信号处理程序和信号处置、当前工作目录、用户ID和组ID。但是每个线程有自己的线程ID、寄存器集合（包括程序计数器和栈指针）、栈（用于存放局部变量和返回地址）、error、信号掩码、优先级。

# 1. 线程基础介绍
## 数据结构
```C
pthread_t       // 线程id
pthread_attr_t  // 线程属性
```
## 操作函数
```C
// 创建一个线程
pthread_create()
// 终止当前线程
pthread_exit()
// 中断另外一个线程的运行
pthread_cancel()
// 阻塞当前的线程，直到另外一个线程运行结束
pthread_join()
// 初始化线程的属性
pthread_attr_init()
// 设置脱离状态的属性（决定这个线程在终止时是否可以被结合）
pthread_attr_setdetachstate()
// 获取脱离状态的属性
pthread_attr_getdetachstate()
// 删除线程的属性
pthread_attr_destroy()
// 向线程发送一个信号
pthread_kill()
```

## 同步函数
```C
/* 用于 mutex 和条件变量 */
// 初始化互斥锁
pthread_mutex_init()
// 删除互斥锁
pthread_mutex_destroy()
// 占有互斥锁（阻塞操作）
pthread_mutex_lock()
// 试图占有互斥锁（不阻塞操作）。即当互斥锁空闲时，将占有该锁；否则，立即返回。
pthread_mutex_trylock()
// 释放互斥锁
pthread_mutex_unlock()
// 初始化条件变量
pthread_cond_init()
// 销毁条件变量
pthread_cond_destroy()
// 唤醒第一个调用pthread_cond_wait()而进入睡眠的线程
pthread_cond_signal()
// 等待条件变量的特殊条件发生
pthread_cond_wait()

/* Thread-local storage（或者以Pthreads术语，称作线程特有数据） */
// 分配用于标识进程中线程特定数据的键
pthread_key_create()
// 为指定线程特定数据键设置线程特定绑定
pthread_setspecific()
// 获取调用线程的键绑定，并将该绑定存储在 value 指向的位置中
pthread_getspecific()
// 销毁现有线程特定数据键
pthread_key_delete()
// 获取线程优先级
pthread_attr_getschedparam()
// 设置线程优先级
pthread_attr_setschedparam()
```

# 2. 概念
线程的组成部分：  
- Thread ID
- Stack
- Policy
- Signal mask
- Errno
- Thread-Specific Data

# 3. 线程定义
1. `pthread_t pthread_ID`用于标识一个线程，不能单纯看成整数，可能是结构体，与实现有关  
2. `pthread_equal`函数用于比较两个pthread_t是否相等
```C
#include <pthread.h>

int pthread_equal(pthread_t tid1, pthread_t tid2);
```
3. `pthread_self`函数用于获取本线程的thread id
```C
#include <pthread.h>

pthread_t pthread_self(void);
```

# 4. 线程的创建
1. 创建线程调用`pthread_create`函数：
```C
#include <pthread.h>

int pthread_create(
    pthread_t *restrict tidp,
    const pthread_attr_t *restrict attr,
    void *(*start_rtn)(void *), 
    void *restrict arg);
)
```


